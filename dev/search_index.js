var documenterSearchIndex = {"docs":
[{"location":"#RRRMC.jl-documentation-1","page":"Home","title":"RRRMC.jl documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"CurrentModule = RRRMC","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This code implements the Reduced-Rejection-Rate (RRR) Monte Carlo method for Ising spin models described in the paper \"A method to reduce the rejection rate in Monte Carlo Markov Chains\" by C. Baldassi, J. Stat. Mech. Theor. Exp., (2017) 3, 033301 doi:10.1088/1742-5468/aa5335 (arXiv).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"It also provides:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"a standard Metropolis-Hastings sampler\na generalized implementation of the BKL method described in the paper \"A new algorithm for Monte Carlo simulation of Ising spin systems\" by A.B. Bortz, M.H. Kalos and J.L. Lebowitz. The generalization consists in not requiring that the energy shifts are discrete.\nan implementation of the Waiting time method described in the paper \"Faster Monte Carlo simulations at low temperatures. The waiting time method\" by J. Dall and P. Sibani.\nan implementation of the \"τ-Extremal Optimization\" heuristic technique described in the paper \"Optimization with Extremal Dynamics\" by S. Boettcher and A. G. Percus.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The code is written in Julia. It requires Julia 1.0.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To install the package, use Julia's package manager: from the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pkg> add RRRMC","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Or, equivalently, via the Pkg API:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> import Pkg; Pkg.add(\"RRRMC\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Dependencies will be installed automatically.","category":"page"},{"location":"#Usage-1","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The module is loaded as any other Julia module:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> using RRRMC","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The module provides four functions which implement Monte Carlo Markov Chain algorithms on Ising spin models:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"standardMC: a standard Metropolis-Hastings sampler\nrrrMC: the reduced-rejection-rate (RRR) method\nbklMC: the Bortz-Kalos-Lebowitz (BKL) method\nwtmMC: the waiting-time method (WTM)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The interface for these four algorithms is documented in the Sampling algorithms page, and it is essentially identical: they take as arguments a graph, an inverse temperature parameter β, and the number of Monte Carlo iterations to perform (or, for wtmMC, of samples to collect). However, the sampling methodology changes based on the type of model, see the Graph types page.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The module also provides the function extremal_opt, which implements the τ-Extremal Optimization heuristic technique, used to seek the ground state of a model. The interface for this function is similar, but not identical, to the others, due to its different purpose.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"All of the above functions allow accessing the internal state during the iteration at regular intervals, via the hook keyword argument. They also return the final configuration of the system, which is stored in an object of type Config. (The extremal_opt function also returns the best configuration found.)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The code comes with some built-in graphs, but provides an interface to write user-defined models.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nThe four sampling functions are the only names exported by the module; all other function and types must be qualified with the RRRMC module name.","category":"page"},{"location":"#Manual-1","page":"Home","title":"Manual","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"algorithms.md\",\n    \"graph-types.md\",\n    \"graphs-builtin.md\",\n    \"interface.md\",\n    ]\nDepth = 3","category":"page"},{"location":"algorithms/#algorithms-1","page":"Sampling algorithms","title":"Sampling algorithms","text":"","category":"section"},{"location":"algorithms/#","page":"Sampling algorithms","title":"Sampling algorithms","text":"CurrentModule = RRRMC","category":"page"},{"location":"algorithms/#","page":"Sampling algorithms","title":"Sampling algorithms","text":"standardMC","category":"page"},{"location":"algorithms/#RRRMC.standardMC","page":"Sampling algorithms","title":"RRRMC.standardMC","text":"standardMC(X::AbstractGraph, β::Real, iters::Integer; keywords...)\n\nRuns iters iterations of a standard Metropolis Monte Carlo algorithm on the given Ising spin model X, at inverse temperature β. Each spin flip attempt counts as an iteration.\n\nReturns two objects: a vector of energies and the last configuration (see Config).\n\nPossible keyord arguments are:\n\nstep: the interval of iterations with which to collect energies (for the returned result) and to call the hook function (see below). The default is 1, which is good for debugging but otherwise generally a bad idea.\nseed: the random seed. The default is some arbitrary number.\nC0: the initial configuration. The default is nothing, in which case it is initialized at random. Otherwise it can be a Config object. Passing the result of a previous run can be useful e.g. when implementing a simulated annealing protocol, or if the system has not equilibrated yet.\nhook: a function to be executed after every step number of iterations (see above). It must take five arguments: the current iteration, the graph X, the current configuration, the number of accepted moves so far, and the current energy. Useful to collect data other than the energy, write to files ecc; you'd probably want to use a closure, see the example below. The return value must be a Bool: return false to interrupt the simulation, true otherwise. The default does nothing and just returns true.\n\nBasic example:\n\njulia> Random.seed!(76543); X = RRRMC.GraphPSpin3(3999, 5); β = 1.0;\njulia> Es, C = standardMC(X, β, 100_000, step = 1_000);\n\nExample of using the hook for collecting samples as the columns of a BitMatrix:\n\njulia> iters = 100_000; step = 1_000; l = iters ÷ step; N = RRRMC.getN(X);\njulia> Cs = BitArray(undef, N, l); hook = (it, X, C, acc, E) -> (Cs[:,it÷step]=C.s; true);\njulia> Es, C = standardMC(X, β, iters, step = step, hook = hook);\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#","page":"Sampling algorithms","title":"Sampling algorithms","text":"rrrMC","category":"page"},{"location":"algorithms/#RRRMC.rrrMC","page":"Sampling algorithms","title":"RRRMC.rrrMC","text":"rrrMC(X::AbstractGraph, β::Real, iters::Integer; keywords...)\n\nSame as standardMC, but uses the reduced-rejection-rate method. Each iteration takes more time, but has a higher chance of being accepted, so fewer iterations overall should be needed normally. Whether this trade-off is convenient depends on the parameters and the details of the model. This function has specialized versions for DiscrGraph and DoubleGraph models.\n\nThe return values and the keyword arguments are the same as standardMC, see the usage examples for that function.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#","page":"Sampling algorithms","title":"Sampling algorithms","text":"bklMC","category":"page"},{"location":"algorithms/#RRRMC.bklMC","page":"Sampling algorithms","title":"RRRMC.bklMC","text":"bklMC(X::AbstractGraph, β::Real, iters::Integer; keywords...)\n\nSame as standardMC, but uses the rejection-free method by Bortz, Kalos and Lebowitz. Each step takes more time, but rejected moves are almost free, since they are skipped entirely. This function has a specialized version for DiscrGraph models.\n\nThe return values and the keyword arguments are the same as standardMC, see the usage examples for that function.\n\nNote that the number of iterations includes the rejected moves. This makes the results directly comparable with those of standardMC. It also means that increasing β at fixed iters will result in fewer steps being actually computed.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#","page":"Sampling algorithms","title":"Sampling algorithms","text":"wtmMC","category":"page"},{"location":"algorithms/#RRRMC.wtmMC","page":"Sampling algorithms","title":"RRRMC.wtmMC","text":"wtmMC(X::AbstractGraph, β::Real, samples::Integer; keywords...)\n\nSame as standardMC, but uses the rejection-free waiting-time method by Dall and Sibani. It is similar to bklMC.\n\nThe return values and the keyword arguments are almost the same as standardMC, see the usage examples for that function. However, the waiting time method uses an internal \"global time\" variable, which takes the place of the \"iterations\" counter of standardMC and of bklMC. Thus, this function has two differences with respect to the other samplers in the module:\n\nthe function takes a samples integer argument, with the maximum number of samples which will be collected.\nthe step keyword argument is of type Float64 instead of integer (default value = 1.0; you'll probably want to change this). The step is measured in terms of the global time variable and is scaled with the size of the problem N.\n\nThe total number of samples actually collected can still be less than samples if the hook function from the keyword arguments returns false earlier.\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#","page":"Sampling algorithms","title":"Sampling algorithms","text":"extremal_opt","category":"page"},{"location":"algorithms/#RRRMC.extremal_opt","page":"Sampling algorithms","title":"RRRMC.extremal_opt","text":"extremal_opt(X::AbstractGraph, τ::Real, iters::Integer; keywords...)\n\nExtremal optimization algorithm: it seeks the lowest energy state of a given Ising spin model X by performing a random walk biased towards low-energy states, but with a heavy tail which allows it to avoid getting trapped.\n\nThe interface is very similar to that of standardMC and the other RRRMC Monte Carlo functions, but it takes a parameter τ instead of β, the return values are different, and the hook keyword argument has a different signature, see below.\n\nThe parameter τ controls the shape of the tail and should be larger than 1 (a reasonable value could be 1.3); iters is the total number of spin flips performed.\n\nThis function has a specialized version for DiscrGraph models; otherwise, it works but it is not implemented very efficiently at the moment (each spin flip takes O(N) time even on diluted graphs).\n\nReturns 4 objects: the final configuration, the minimum energy found, the configuration of minimum energy, and the iteration at which such configuration was found (see Config).\n\nPossible keyord arguments are:\n\nstep: the interval of iterations with which to call the hook function (see below). The default is 1, which is good for debugging but otherwise generally a bad idea, probably.\nseed: the random seed. The default is some arbitrary number.\nC0: the initial configuration. The default is nothing, in which case it is initialized at random. Otherwise it can be a Config object.\nhook: a function to be executed after every step number of iterations (see above). It must take five arguments: the current iteration, the graph X, the current configuration, the current energy, and the minimum energy found so far. Useful to collect data other than the energy, write to files ecc; you'd probably want to use a closure, see the example below. The return value must be a Bool: return false to interrupt the simulation, true otherwise. The default does nothing and just returns true. Note that the signature is similar to that of the corresponding hook argument in standardMC, but different.\n\nBasic example:\n\njulia> Random.seed!(76543); X = RRRMC.GraphPSpin3(3999, 5); τ = 1.3;\njulia> C, Emin, Cmin, itmin = extremal_opt(X, τ, 100_000, step = 1_000);\n\nExample of using the hook for collecting samples as the columns of a BitMatrix:\n\njulia> iters = 100_000; step = 1_000; l = iters ÷ step; N = RRRMC.getN(X);\njulia> Cs = BitArray(undef, N, l); hook = (it, X, C, E, Emin) -> (Cs[:,it÷step]=C.s; true);\njulia> C, Emin, Cmin, itmin = extremal_opt(X, τ, iters, step = step, hook = hook);\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#","page":"Sampling algorithms","title":"Sampling algorithms","text":"Config","category":"page"},{"location":"algorithms/#RRRMC.Interface.Config","page":"Sampling algorithms","title":"RRRMC.Interface.Config","text":"Config(N::Integer)\n\nThe object storing the configuration for an Ising model. Although the spin values are σ_i  -11, internally they are stored in a BitArray, in the type field s, so that to obtain the real value one needs to perform the transformation σ_i = 2s_i - 1.\n\n\n\n\n\n","category":"type"},{"location":"graph-types/#graphtype-1","page":"Graph types","title":"Graph types","text":"","category":"section"},{"location":"graph-types/#","page":"Graph types","title":"Graph types","text":"CurrentModule = RRRMC","category":"page"},{"location":"graph-types/#","page":"Graph types","title":"Graph types","text":"All graphs which can be used with the sampling algorithms belong to a type hierarchy. At the top of the hierarchy, there is AbstractGraph:","category":"page"},{"location":"graph-types/#","page":"Graph types","title":"Graph types","text":"AbstractGraph","category":"page"},{"location":"graph-types/#RRRMC.Interface.AbstractGraph","page":"Graph types","title":"RRRMC.Interface.AbstractGraph","text":"AbstractGraph{ET<:Real}\n\nAn abstract type representing an Ising spin model. The ET parameter is the type returned by the energy and delta_energy functions.\n\nSee also SimpleGraph, DiscrGraph, SingleGraph and DoubleGraph.\n\n\n\n\n\n","category":"type"},{"location":"graph-types/#","page":"Graph types","title":"Graph types","text":"There are currently three abstract subclasses and an alias, which determine how the sampling algorithms can be used:","category":"page"},{"location":"graph-types/#","page":"Graph types","title":"Graph types","text":"SimpleGraph","category":"page"},{"location":"graph-types/#RRRMC.Interface.SimpleGraph","page":"Graph types","title":"RRRMC.Interface.SimpleGraph","text":"SimpleGraph{ET} <: AbstractGraph{ET}\n\nAn abstract type representing a generic graph.\n\nThe ET parameter is the type returned by energy and delta_energy.\n\n\n\n\n\n","category":"type"},{"location":"graph-types/#","page":"Graph types","title":"Graph types","text":"DiscrGraph","category":"page"},{"location":"graph-types/#RRRMC.Interface.DiscrGraph","page":"Graph types","title":"RRRMC.Interface.DiscrGraph","text":"DiscrGraph{ET} <: AbstractGraph{ET}\n\nAn abstract type representing a graph in which the delta_energy values produced when flipping a spin belong to a finite discrete set, and thus can be sampled more efficiently with rrrMC or bklMC if the set is small.\n\nThe ET parameter is the type returned by energy and delta_energy.\n\nSee also allΔE.\n\n\n\n\n\n","category":"type"},{"location":"graph-types/#","page":"Graph types","title":"Graph types","text":"SingleGraph","category":"page"},{"location":"graph-types/#RRRMC.Interface.SingleGraph","page":"Graph types","title":"RRRMC.Interface.SingleGraph","text":"SingleGraph{ET}\n\nA type alias representing either a SimpleGraph or a DiscrGraph{ET}. See also DoubleGraph.\n\n\n\n\n\n","category":"constant"},{"location":"graph-types/#","page":"Graph types","title":"Graph types","text":"DoubleGraph","category":"page"},{"location":"graph-types/#RRRMC.Interface.DoubleGraph","page":"Graph types","title":"RRRMC.Interface.DoubleGraph","text":"DoubleGraph{GT<:SingleGraph,ET} <: AbstractGraph{ET}\n\nAn abstract type representing a graph in which the energy is the sum of two contributions, one of which is encoded in a graph of type GT (see SingleGraph). This allows rrrMC to sample values more efficiently.\n\nThe ET parameter is the type returned by the energy and delta_energy functions. Note that it can be different from the energy type of the internal GT object (e.g., one can have a DoubleGraph{DiscrGraph{Int},Float64} object).\n\nNote: When you declare a type as subtype of this, GT should not be the concrete type of the inner graph, but either SimpleGraph{T} or DiscrGraph{T} for some T.\n\nSee also inner_graph, delta_energy_residual and update_cache_residual!.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#builtin-1","page":"Built-in graphs","title":"Built-in graphs","text":"","category":"section"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"CurrentModule = RRRMC","category":"page"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"Following is the list of the graph models which are provided with the module. After loading the RRRMC module, they can be constructed like in this example:","category":"page"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"julia> X = RRRMC.GraphRRG(10, 3)","category":"page"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"Note that for models which involve randomness in the constructor you may want to set the random seed with Random.seed! before calling the constructor, for reproducibility purposes.","category":"page"},{"location":"graphs-builtin/#Basic-spin-glass-models-1","page":"Built-in graphs","title":"Basic spin glass models","text":"","category":"section"},{"location":"graphs-builtin/#Random-regular-graphs-1","page":"Built-in graphs","title":"Random regular graphs","text":"","category":"section"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphRRG","category":"page"},{"location":"graphs-builtin/#RRRMC.RRG.GraphRRG","page":"Built-in graphs","title":"RRRMC.RRG.GraphRRG","text":"GraphRRG(N::Integer, K::Integer, LEV = (-1,1)) <: DiscrGraph\n\nA DiscGraph implementing a random regular graph with N spins and connectivity K. Note: N*K must be even. Also, the graph generator uses the pairing model method by Bollobás, with a cutoff on the number of restarts, and thus it may occasionally fail if K is large.\n\nThe interactions are extracted at random from LEV, which must be a Tuple of Reals. No external fields.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphRRGNormal","category":"page"},{"location":"graphs-builtin/#RRRMC.RRG.GraphRRGNormal","page":"Built-in graphs","title":"RRRMC.RRG.GraphRRGNormal","text":"GraphRRGNormal(N::Integer, K::Integer) <: SimpleGraph{Float64}\n\nA SimpleGraph implementing a random regular graph with N spins and connectivity K. Note: N*K must be even. Also, the graph generator uses the pairing model method by Bollobás, with a cutoff on the number of restarts, and thus it may occasionally fail if K is large.\n\nSame as GraphRRG, but the interactions are extracted from a normal distribution with unit variance.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphRRGNormalDiscretized","category":"page"},{"location":"graphs-builtin/#RRRMC.RRG.GraphRRGNormalDiscretized","page":"Built-in graphs","title":"RRRMC.RRG.GraphRRGNormalDiscretized","text":"GraphRRGNormalDiscretized(N::Integer, K::Integer, LEV) <: DoubleGraph{DiscrGraph,Float64}\n\nA DoubleGraph implementing a random regular graph with N spins and connectivity K. Note: N*K must be even. Also, the graph generator uses the pairing model method by Bollobás, with a cutoff on the number of restarts, and thus it may occasionally fail if K is large.\n\nThe interactions are extracted from a normal distribution with unit variance, and are then discretized using the values in LEV, which must be a Tuple of Reals. No external fields.\n\nSame as GraphRRGNormal, but it works differently when used with rrrMC.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#Edwards-Anderson-graphs-1","page":"Built-in graphs","title":"Edwards-Anderson graphs","text":"","category":"section"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphEA","category":"page"},{"location":"graphs-builtin/#RRRMC.EA.GraphEA","page":"Built-in graphs","title":"RRRMC.EA.GraphEA","text":"GraphEA(L::Integer, D::Integer, LEV = (-1,1)) <: DiscrGraph\n\nAn Edwards-Anderson DiscrGraph: spins are arranged on a square lattice of size L in D dimensions (i.e. there are L^D total spins), with periodic boundary conditions.\n\nThe interactions are extracted at random from LEV, which must be a Tuple of Reals. No external fields.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphEANormal","category":"page"},{"location":"graphs-builtin/#RRRMC.EA.GraphEANormal","page":"Built-in graphs","title":"RRRMC.EA.GraphEANormal","text":"GraphEANormal(L::Integer, D::Integer) <: SimpleGraph{Float64}\n\nAn Edwards-Anderson SimpleGraph: spins are arranged on a square lattice of size L in D dimensions (i.e. there are L^D total spins), with periodic boundary conditions.\n\nSame as GraphEA, but the interactions are extracted from a normal distribution with unit variance.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphEANormalDiscretized","category":"page"},{"location":"graphs-builtin/#RRRMC.EA.GraphEANormalDiscretized","page":"Built-in graphs","title":"RRRMC.EA.GraphEANormalDiscretized","text":"GraphEANormalDiscretized(L::Integer, D::Integer, LEV) <: DoubleGraph{DiscrGraph,Float64}\n\nAn Edwards-Anderson DoubleGraph: spins are arranged on a square lattice of size L in D dimensions (i.e. there are L^D total spins), with periodic boundary conditions.\n\nThe interactions are extracted at random from a normal distribution with unit variance, and are then discretized using the values in LEV, which must be a Tuple of Reals. No external fields.\n\nSame as GraphEANormal, but works differently when used with rrrMC.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#p-spin-1","page":"Built-in graphs","title":"p-spin","text":"","category":"section"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphPSpin3","category":"page"},{"location":"graphs-builtin/#RRRMC.PSpin3.GraphPSpin3","page":"Built-in graphs","title":"RRRMC.PSpin3.GraphPSpin3","text":"GraphPSpin3(N::Integer, K::Integer) <: DiscrGraph{Int}\n\nA DiscrGraph implementing a p-spin regular graph with p=3. N is the number of spins, and must be divisible by 3; K is the connectivity. All interactions are set to J=1.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#Sherrington-Kirkpatrick-graphs-1","page":"Built-in graphs","title":"Sherrington-Kirkpatrick graphs","text":"","category":"section"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphSK","category":"page"},{"location":"graphs-builtin/#RRRMC.SK.GraphSK","page":"Built-in graphs","title":"RRRMC.SK.GraphSK","text":"GraphSK(N::Integer) <: SimpleGraph{Float64}\n\nA SimpleGraph implementing a Sherrington-Kirkpatrick fully-connected Ising model with N spins and random binary interactions (J  -1N1N) and no external fields.\n\nSame as GraphSKNormal, but with binary interactions.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphSKNormal","category":"page"},{"location":"graphs-builtin/#RRRMC.SK.GraphSKNormal","page":"Built-in graphs","title":"RRRMC.SK.GraphSKNormal","text":"GraphSK(N::Integer) <: SimpleGraph{Float64}\n\nA SimpleGraph implementing a Sherrington-Kirkpatrick fully-connected Ising model with N spins and random interactions extracted from a normal distribution with zero mean and 1N variance, and no external fields.\n\nSame as GraphSK, but with Gaussian interactions.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#Binary-Neural-Networks-1","page":"Built-in graphs","title":"Binary Neural Networks","text":"","category":"section"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphPercStep","category":"page"},{"location":"graphs-builtin/#RRRMC.PercStep.GraphPercStep","page":"Built-in graphs","title":"RRRMC.PercStep.GraphPercStep","text":"GraphPercStep(N::Integer, P::Integer) <: SimpleGraph{Int}\n\nA SimpleGraph implementing a single-layer binary perceptron with N binary (1) synapses, trained on P random i.i.d. 1 patterns.\n\nThe energy of the model is computed as the number of misclassified patterns.\n\nSee also GraphPercLinear, GraphPercXEntr.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphPercLinear","category":"page"},{"location":"graphs-builtin/#RRRMC.PercLinear.GraphPercLinear","page":"Built-in graphs","title":"RRRMC.PercLinear.GraphPercLinear","text":"GraphPercLinear(N::Integer, P::Integer) <: SimpleGraph{Float64}\n\nA SimpleGraph implementing a single-layer binary perceptron with N binary (1) synapses, trained on P random i.i.d. 1 patterns.\n\nThe energy of the model is computed for each pattern as the minimum number of weights which need to be flipped in order to satisfy that pattern.\n\nSee also GraphPercStep, GraphPercXEntr.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphPercXEntr","category":"page"},{"location":"graphs-builtin/#RRRMC.PercXEntr.GraphPercXEntr","page":"Built-in graphs","title":"RRRMC.PercXEntr.GraphPercXEntr","text":"GraphPercXEntr(N::Integer, P::Integer, λ::Float64) <: SimpleGraph{Float64}\n\nA SimpleGraph implementing a single-layer binary perceptron with N binary (1) synapses, trained on P random i.i.d. 1 patterns.\n\nThe energy of the model is computed for each pattern using the cross-entropy loss (with a λ parameter: log(1 + exp(-2λ σξ  N)).\n\nSee also GraphPercStep, GraphPercLinear\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphCommStep","category":"page"},{"location":"graphs-builtin/#RRRMC.CommStep.GraphCommStep","page":"Built-in graphs","title":"RRRMC.CommStep.GraphCommStep","text":"GraphCommStep(K1::Integer, K2::Integer, P::Integer) <: SimpleGraph{Int}\n\nA SimpleGraph implementing a two-layer fully-connected binary committee machine with K2 hidden units, where each hidden unit has K1 binary (1) synapses, trained on P random i.i.d. 1 patterns.\n\nThe energy of the model is computed as the number of misclassified patterns.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#SAT-1","page":"Built-in graphs","title":"SAT","text":"","category":"section"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphSAT","category":"page"},{"location":"graphs-builtin/#RRRMC.SAT.GraphSAT","page":"Built-in graphs","title":"RRRMC.SAT.GraphSAT","text":"GraphSAT(N::Integer, α::Real, K::Integer)\n\nA DiscrGraph implementing a random K-SAT graph with N spins and αN clauses.\n\nThe energy of the model is the number of violated clauses.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#Quantum-models-with-transverse-fields-1","page":"Built-in graphs","title":"Quantum models with transverse fields","text":"","category":"section"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphQuant","category":"page"},{"location":"graphs-builtin/#RRRMC.QT.GraphQuant","page":"Built-in graphs","title":"RRRMC.QT.GraphQuant","text":"GraphQuant(N::Integer, M::Integer, Γ::Float64, β::Float64, Gconstr, args...) <: DoubleGraph\n\nA DoubleGraph which implements a quantum Ising spin model in a transverse magnetic field, using the Suzuki-Trotter transformation. This allows to model the quantum transverse field case for any classical Ising model previously defined. This kind of graph can be simulated efficiently with rrrMC.\n\nN is the number of spins, M the number of Suzuki-Trotter replicas, Γ the transverse field, β the inverse temperature. GConstr is the (classical) graph constructor, and args the arguments to the contructor.\n\nSee also Qenergy and transverse_mag.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#Robust-Ensemble-models-1","page":"Built-in graphs","title":"Robust Ensemble models","text":"","category":"section"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphRobustEnsemble","category":"page"},{"location":"graphs-builtin/#RRRMC.RE.GraphRobustEnsemble","page":"Built-in graphs","title":"RRRMC.RE.GraphRobustEnsemble","text":"GraphRobustEnsemble(N::Integer, M::Integer, γ::Float64, β::Float64, Gconstr, args...) <: DoubleGraph\n\nA DoubleGraph which implements a \"Robust Ensemble\" model, given any other Ising model previously defined. This kind of graph can be simulated efficiently with rrrMC.\n\nN is the number of spins, M the number of replicas, γ the interaction strength, β the inverse temperature. GConstr is the (original) graph constructor, and args the arguments to the contructor.\n\nThis is similar to GraphLocalEntropy, but the reference configuration is traced out.\n\nSee also REenergies.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#Local-Entropy-models-1","page":"Built-in graphs","title":"Local Entropy models","text":"","category":"section"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphLocalEntropy","category":"page"},{"location":"graphs-builtin/#RRRMC.LE.GraphLocalEntropy","page":"Built-in graphs","title":"RRRMC.LE.GraphLocalEntropy","text":"GraphLocalEntropy(N::Integer, M::Integer, γ::Float64, β::Float64, Gconstr, args...) <: DoubleGraph\n\nA DoubleGraph which implements a \"Local Entropy\" model, given any other Ising model previously defined. This simulates a replicated system in which each replica interacts with an extra \"reference\" configuration. This kind of graph can be simulated efficiently with rrrMC.\n\nN is the number of spins, M the number of replicas, γ the interaction strength, β the inverse temperature. GConstr is the (original) graph constructor, and args the arguments to the contructor.\n\nThis is similar to GraphRobustEnsemble, but the reference is simulated explicitly.\n\nSee also LEenergies and cenergy.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphTopologicalLocalEntropy","category":"page"},{"location":"graphs-builtin/#RRRMC.TLE.GraphTopologicalLocalEntropy","page":"Built-in graphs","title":"RRRMC.TLE.GraphTopologicalLocalEntropy","text":"GraphTopologicalLocalEntropy(N::Integer, M::Integer, γ::Float64, λ::Float64, β::Float64, Gconstr, args...) <: DoubleGraph\n\nA DoubleGraph which implements a \"Local Entropy\" model, given any other Ising model previously defined. This simulates a replicated system in which each replica interacts with an extra \"reference\" configuration. This kind of graph can be simulated efficiently with rrrMC.\n\nN is the number of spins, M the number of replicas, γ the interaction strength of the replicas with the reference, λ is the topological interaction strenght, β the inverse temperature. GConstr is the (original) graph constructor, and args the arguments to the contructor.\n\nThis is similar to GraphLocalEntropy, but with the additional topological interaction.\n\nSee also TLEenergies and cenergy.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#Trivial-models-used-for-testing-and-debugging-1","page":"Built-in graphs","title":"Trivial models used for testing and debugging","text":"","category":"section"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphEmpty","category":"page"},{"location":"graphs-builtin/#RRRMC.Empty.GraphEmpty","page":"Built-in graphs","title":"RRRMC.Empty.GraphEmpty","text":"GraphEmpty(N::Integer) <: SimpleGraph{Int}\n\nA trivial SimpleGraph type with N free, non-interacting spins. (The energy is always 0.)\n\nOnly useful for testing/debugging purposes.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphTwoSpin","category":"page"},{"location":"graphs-builtin/#RRRMC.TwoSpin.GraphTwoSpin","page":"Built-in graphs","title":"RRRMC.TwoSpin.GraphTwoSpin","text":"GraphTwoSpin() <: DiscrGraph{Int}\n\nA trivial DiscrGraph type with 2 spins inteacting ferromagnetically (J=1), without fields.\n\nOnly useful for testing/debugging purposes.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphThreeSpin","category":"page"},{"location":"graphs-builtin/#RRRMC.ThreeSpin.GraphThreeSpin","page":"Built-in graphs","title":"RRRMC.ThreeSpin.GraphThreeSpin","text":"GraphThreeSpin() <: DiscrGraph{Int}\n\nA trivial DiscrGraph type with 3 spins, ferromagnetic interactions (J=1), no fields, and periodic boundary conditions.\n\nOnly useful for testing/debugging purposes.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphFields","category":"page"},{"location":"graphs-builtin/#RRRMC.Fields.GraphFields","page":"Built-in graphs","title":"RRRMC.Fields.GraphFields","text":"GraphFields(N::Integer, LEV::Tuple = (1,)) <: DiscrGraph\n\nA simple DiscrGraph type with N non-interacting variables, each of which is subject to a local field. The fields are extracted at random from LEV, which must be a Tuple of Reals.\n\nMostly useful for testing/debugging purposes.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphFieldsNormalDiscretized","category":"page"},{"location":"graphs-builtin/#RRRMC.Fields.GraphFieldsNormalDiscretized","page":"Built-in graphs","title":"RRRMC.Fields.GraphFieldsNormalDiscretized","text":"GraphFieldsNormalDiscretized(N::Integer, LEV::Tuple) <: DoubleGraph{Float64,GraphFields}\n\nA simple DoubleGraph type with N non-interacting variables, each of which is subject to a local field. The fields are extracted independently from a normal distribution with unit variance, and then are discretized using the values in LEV, which must be a Tuple of Reals.\n\nMostly useful for testing/debugging purposes.\n\n\n\n\n\n","category":"type"},{"location":"graphs-builtin/#","page":"Built-in graphs","title":"Built-in graphs","text":"GraphIsing1D","category":"page"},{"location":"graphs-builtin/#RRRMC.Ising1D.GraphIsing1D","page":"Built-in graphs","title":"RRRMC.Ising1D.GraphIsing1D","text":"GraphIsing1D(N::Integer) <: DiscrGraph{Int}\n\nA simple 1-dimensional DiscrGraph type with N spins, antiferromagnetic interactions (J=-1), no fields, and periodic boundary conditions.\n\nMostly useful for testing/debugging purposes.\n\n\n\n\n\n","category":"type"},{"location":"interface/#interface-1","page":"Graphs interface","title":"Graphs interface","text":"","category":"section"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"CurrentModule = RRRMC","category":"page"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"This page contains all the functions which are needed when implementing a graph type. See the built-in graphs for concrete examples (in particular, the SK, RRG and EA family of graphs have the most complete implementations). See also the documentation for the Config type.","category":"page"},{"location":"interface/#Functions-used-by-all-graph-types-1","page":"Graphs interface","title":"Functions used by all graph types","text":"","category":"section"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"energy","category":"page"},{"location":"interface/#RRRMC.Interface.energy","page":"Graphs interface","title":"RRRMC.Interface.energy","text":"energy(X::AbstractGraph, C::Config)\n\nReturns the energy of graph X in the configuration C. This is always invoked at the beginning of standardMC, rrrMC, bklMC and wtmMC. Subsequently, delta_energy is used instead.\n\nAll graphs must implement this function.\n\nIt must also be used to initialize/reset the cache for a given graph, if any (see update_cache!).\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"delta_energy","category":"page"},{"location":"interface/#RRRMC.Interface.delta_energy","page":"Graphs interface","title":"RRRMC.Interface.delta_energy","text":"delta_energy(X::AbstractGraph, C::Config, move::Int)\n\nReturns the energy difference that would be associated to flipping the spin move.\n\nA default fallback implementation based on energy is provided, to be used for debugging, but having an efficient implementation for each graph is critical for performance.\n\nNote: when X is a DiscrGraph, the absolute value of the result must be contained in the tuple returned by allΔE – no approximations are allowed, and missing values will cause crashes (unless Julia is run with the --check-bounds=yes option, in which case they will cause errors).\n\nNote: this function is always invoked before performing the flip, unlike in update_cache! and update_cache_residual!.\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"update_cache!","category":"page"},{"location":"interface/#RRRMC.Interface.update_cache!","page":"Graphs interface","title":"RRRMC.Interface.update_cache!","text":"update_cache!(X::AbstractGraph, C::Config, move::Int)\n\nA function which is called every time a spin is flipped. This may happen:\n\nwhen a move is accepted, in standardMC, rrrMC, bklMC and wtmMC.\nwhen a move is attempted to evaluate the effect on the neighbors, in rrrMC.\n\nmove is the spin index. By default, this function does nothing, but it may be overloaded by particular graph types.\n\nWhen X is a DoubleGraph, there is a default implementation which first calls update_cache! on inner_graph(X), then calls update_cache_residual! on X.\n\nNote: this function is always invoked after the flip has been performed, unlike in delta_energy and delta_energy_residual.\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"getN","category":"page"},{"location":"interface/#RRRMC.Interface.getN","page":"Graphs interface","title":"RRRMC.Interface.getN","text":"getN(X::AbstractGraph)\n\nReturns the number of spins for a graph. The default implementation just returns X.N.\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"neighbors","category":"page"},{"location":"interface/#RRRMC.Interface.neighbors","page":"Graphs interface","title":"RRRMC.Interface.neighbors","text":"neighbors(X::AbstractGraph, i::Int)\n\nReturns an iterable with all the neighbors of spin i. This is required by rrrMC, bklMC and wtmMC since those methods need to evaluate the effect of flipping a spin on its neighbors' local fields. It is not required by standardMC.\n\nFor performance reasons, it is best if the returned value is stack-allocated rather than heap-allocated, e.g. it is better to return an NTuple than a Vector.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Functions-used-by-DiscrGraph-models-1","page":"Graphs interface","title":"Functions used by DiscrGraph models","text":"","category":"section"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"allΔE","category":"page"},{"location":"interface/#RRRMC.Interface.allΔE","page":"Graphs interface","title":"RRRMC.Interface.allΔE","text":"allΔE{P<:DiscrGraph}(::Type{P})\nallΔE(X::DiscrGraph)\n\nReturns a tuple of all possible non-negative values that can be returned by delta_energy. This must be implemented by all DiscrGraph objects in order to use rrrMC or bklMC.\n\nThe second form above, called directly on the DiscrGraph object, takes precedence; however, for performance reasons, it is best if the result can be computed from the type of the graph alone (possibly using a generated function), i.e. it is best to implement the first definition above — the second one then falls back automatically to the first.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Functions-used-by-DoubleGraph-models-1","page":"Graphs interface","title":"Functions used by DoubleGraph models","text":"","category":"section"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"inner_graph","category":"page"},{"location":"interface/#RRRMC.Interface.inner_graph","page":"Graphs interface","title":"RRRMC.Interface.inner_graph","text":"inner_graph(X::DoubleGraph)\n\nReturns the internal graph used by the given DoubleGraph. The default implementation simply returns X.X0.\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"delta_energy_residual","category":"page"},{"location":"interface/#RRRMC.Interface.delta_energy_residual","page":"Graphs interface","title":"RRRMC.Interface.delta_energy_residual","text":"delta_energy_residual(X::DoubleGraph, C::Config, move::Int)\n\nReturns the residual part of the energy difference produced if the spin move would be flipped, excluding the contribution from the internal SimpleGraph (see inner_graph).\n\nSee also delta_energy. There is a default fallback implementation, but it should be overloaded for efficiency.\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"update_cache_residual!","category":"page"},{"location":"interface/#RRRMC.Interface.update_cache_residual!","page":"Graphs interface","title":"RRRMC.Interface.update_cache_residual!","text":"update_cache_residual!(X::DoubleGraph, C::Config, move::Int)\n\nCalled internally by the default update_cache! when the argument is a DoubleGraph. Can be useful to overload this if the residual part of the graph has an indipendent cache.\n\nBy default, it does nothing.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Functions-specific-to-quantum-models-1","page":"Graphs interface","title":"Functions specific to quantum models","text":"","category":"section"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"Qenergy","category":"page"},{"location":"interface/#RRRMC.QT.Qenergy","page":"Graphs interface","title":"RRRMC.QT.Qenergy","text":"Qenergy(X::DoubleGraph, C::Config)\n\nWhen using the Suzuki-Trotter transformation to simulate quantum systems in a transverse magnetic field with a replicated classical system, this function should be used to obtain the average value of the Hamiltonian observable (divided by the number of spins).\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"transverse_mag","category":"page"},{"location":"interface/#RRRMC.QT.transverse_mag","page":"Graphs interface","title":"RRRMC.QT.transverse_mag","text":"transverse_mag(X::DoubleGraph, C::Config, β::Float64)\n\nWhen using the Suzuki-Trotter transformation to simulate quantum systems in a transverse magnetic field with a replicated classical system, this function should be used to obtain the average value of the transverse magnetization observable.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Functions-specific-to-robust-ensemble-models-1","page":"Graphs interface","title":"Functions specific to robust-ensemble models","text":"","category":"section"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"REenergies","category":"page"},{"location":"interface/#RRRMC.RE.REenergies","page":"Graphs interface","title":"RRRMC.RE.REenergies","text":"REenergies(X::GraphRobustEnsemble)\n\nReturns a Vector with the individual energy (as defined by the original model) of each replica in a GraphRobustEnsemble graph.\n\n\n\n\n\n","category":"function"},{"location":"interface/#Functions-specific-to-local-entropy-models-1","page":"Graphs interface","title":"Functions specific to local-entropy models","text":"","category":"section"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"LEenergies","category":"page"},{"location":"interface/#RRRMC.LE.LEenergies","page":"Graphs interface","title":"RRRMC.LE.LEenergies","text":"LEenergies(X::GraphLocalEntropy)\n\nReturns a Vector with the individual energy (as defined by the original model) of each replica in a GraphLocalEntropy graph.\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"TLEenergies","category":"page"},{"location":"interface/#RRRMC.TLE.TLEenergies","page":"Graphs interface","title":"RRRMC.TLE.TLEenergies","text":"TLEenergies(X::GraphTopologicalLocalEntropy)\n\nReturns a Vector with the individual energy (as defined by the original model) of each replica in a GraphTopologicalLocalEntropy graph.\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"cenergy","category":"page"},{"location":"interface/#RRRMC.Interface.cenergy","page":"Graphs interface","title":"RRRMC.Interface.cenergy","text":"cenergy(X::DoubleGraph)\n\nReturns the individual energy (as defined by the original model) of the reference configuration in a GraphLocalEntropy graph or a GraphTopologicalLocalEntropy graph.\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"Graphs interface","title":"Graphs interface","text":"distances","category":"page"},{"location":"interface/#RRRMC.Interface.distances","page":"Graphs interface","title":"RRRMC.Interface.distances","text":"distances(X::DoubleGraph)\n\nReturns the matrix of the Hamming distances between replicas, in graphs with replicas: GraphQuant, GraphLocalEntropy, GraphTopologicalLocalEntropy or GraphRobustEnsemble.\n\n\n\n\n\n","category":"function"}]
}
